[Config FastSMR]
network = abstract.FastSMRModel
# network parameters
FastSMRModel.client_num = 10
# the simulation configure determining whether only one single specific logical computer is tested; otherwise, set it to empty string  
FastSMRModel.logical_computer = "client[0]"


# global observer
## global simulation parameters
## maximum distance could be, for example, half of the Earth circumference: 20000000m
**.globalParameters.max_distance = 20000000m
**.globalParameters.fix_latency = 100ms
## network latency generation mode. 
## 0: Simulation of real-world latency generated by 1) light transmission limit, 2) communication congestion, and 3) jitter 
## 1: Latency generation with minimal singl-trip latency (Dmin) and jitter, i.e., Dmin + jitter
**.globalParameters.latency_gen_mode = 0
## global statistics parameters
## the time after which the sent events will not be included in drop rate calculation
**.globalStatistics.cool_down = 10s

# network configurator
**.underlayConfigurator.lcType = "abstract.LogicComputer"
**.underlayConfigurator.lcName = "logicComputer"
**.underlayConfigurator.nodeType = "hosts.Node"
**.underlayConfigurator.nodeName = "node"
**.underlayConfigurator.clientType = "hosts.Client"
**.underlayConfigurator.clientName = "client"

# system-level parameters
#**.delay = 50ms + truncnormal(50ms, ${stddev = 50, 100, 150, 200, 250}ms)

# client parameters
# the cycle for initiating connection trials to the replicas of a logical computer
**.client[*].ctrl.initJoinTime = 3000ms
# the cycle for user to change the "connect" flag to load a logical computer 
**.client[*].ctrl.loadCycle = 500ms
# the cycle for neighbor discovery 
**.client[*].ctrl.discoveryCycle = 1000ms
# whether the schedule of event dispatch at client will be deviated
**.client[*].ctrl.deviate = false

# logical computer parameters

# host parameter
# to minimize the opsportunity of group failure, mean and stdvar should be configured to large values
**.node[*].IPInterface = "IPAddress"
**.node[*].HBcycle = 1000ms

# replica control parameters
**.node[*].ctrl.roundCycle = 200ms
# time to start event collection cycle
**.node[*].ctrl.cycleStart = 4000ms
# garbage collection gossip cycle
**.node[*].ctrl.GCCycle = 5000ms

# Rendezvous parameters
**.rendezvous.ctrl.cycle = 1000ms
**.rendezvous.ctrl.starttime = 5000ms
## for replica number calculation for a new replication
**.rendezvous.replicaNumPolicyModule = "replication"
**.rendezvous.replication.threshold = 3
### for BasicReplicaNumPolicy 
**.rendezvous.replication.max_replica = 5

# clock configurations
**.clock.err_mean = 74ms
**.clock.err_std = 175ms

# UDP packet transmission configuration
## packet loss rate
**.pktLossRate = 0.01
## 2/3 of the light speed
**.Copt = 200000000mps
## 10 mega bits per second
**.BW = 1.04858e6bps
## Ethernet packet size 1518 Bytpes = 12144 bits
**.MTU = 12144b
**.jitter_mu = 1
**.jitter_sigma = 0.5
# minimal end-to-end delay
**.Dmin = 50ms
**.jitter = 50ms

# churn generator configuration
**.churnGeneratorModule = "churnGenerator"
# fraction of stable nodes, from cloud or datacenter servers
**.churnGenerator.stable_fraction = 0.2
# stable node lifetime is modelled by an exponential distribution, mean = 2.5 hours
**.churnGenerator.stable_mean = 9000000ms
## for WeibullChurnGenerator, unit of minutes
**.churnGenerator.sessionLenShape = 0.38
**.churnGenerator.sessionLenScale = 42.4
#**.churnGenerator.sessionLenMin = 10min
**.churnGenerator.sessionLenMin = 10s
## for ManualChurnGenerator, unit of  minutes
**.churnGenerator.sessionLength = 30min
**.churnGenerator.scan_cycle = 100ms
## for UniformChurnGenerator
**.churnGenerator.life_span_min = 10s
**.churnGenerator.life_span_max = 1000s

# For coordinator module
**.coordinator.locXMax = 750
**.coordinator.locYMax = 550
**.coordinator.locXMin = 200
**.coordinator.locYMin = 50
## the boundary of logical computer
**.coordinator.LCXMax = 1050
**.coordinator.LCYMax = 550
**.coordinator.LCXMin = 850
**.coordinator.LCYMin = 50
## radius of percept
**.coordinator.percept_radius=1000

# result recording
**.result-recording-modes = all
**.statistic-recording = true
**.scalar-recording = true

[General]
scheduler-class = "cSequentialScheduler"
# if need real-time telnet support, use SimpleSocketRTScheduler
# microsecond
simtime-resolution = ms
# Minimal time unit of simulation duration can only be second
sim-time-limit = 1020s
warmup-period = 10s
num-rngs = 1
rng-class = cMersenneTwister
seed-0-mt = 200
repeat = 1
#debug-on-errors = false
#cmdenv-event-banners = true
# for performance consideration, the signal check control can be changed to false
check-signals = false
record-eventlog = false